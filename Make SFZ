#!/bin/bash
#
# 'Make SFZ' by RockHopper 2013
#
# This is a Nautilus script to invoke makesfz. It assumes that makesfz is installed
# in a directory included in the PATH environment variable (e.g. /usr/bin, /usr/local/bin) 
# and that xterm is available.
#
# This script is public domain and provided 'as-is', without any express or implied 
# warranty. In no event will the author be held liable for any damages arising from 
# the use of this software.


# These variables may be modified if you need to specify the file path of makesfz
# or if you wish to use a different terminal emulator

MAKESFZ_FILEPATH="makesfz"
TERMINAL_COMMAND="xterm -hold -title MakeSFZ -font 9x15 -e"

# N.B. For a list of available fonts in xterm type: appres XTerm | grep VT100.font
##################################################################################


declare filePaths=""
declare fileType=""
declare prevFileType=""

while IFS="\n" read -r -d $'\n' filePath; do
    filePaths+="\"$filePath\" "
done < <(echo -n "$NAUTILUS_SCRIPT_SELECTED_FILE_PATHS")

while IFS="\n" read -r -d $'\n' filePath; do
    fileType="${filePath##*.}"

    if [[ $fileType != [wW][aA][vV] ]] && [[ $fileType != [fF][lL][aA][cC] ]] && [[ $fileType != [oO][gG][gG] ]]; then
        fileType=""
    fi

    if [ "$prevFileType" != "" ] && [ "$fileType" != "$prevFileType" ]; then
        fileType=""
        break
    fi
    prevFileType="$fileType"
done < <(echo -n "$NAUTILUS_SCRIPT_SELECTED_FILE_PATHS")

commandToExec='function setTextColour { tput setf $1; }; let CYAN=3; let RED=4; let YELLOW=6; let WHITE=7; '
commandToExec+='function startUnderline { tput smul; }; function stopUnderline { tput rmul; }; '
commandToExec+='function moveCursorUpOneLine { tput cuu1; }; '

# Welcome message
commandToExec+='setTextColour $YELLOW; startUnderline; echo -e "\nMake SFZ\n"; stopUnderline; setTextColour $WHITE; '

commandToExec+='cat << EOF
This script will auto-generate one or more SFZ files from the selected 
file(s) and/or dir(s). If no files are selected it will scan the current 
directory for compatible audio files (wav, flac, or ogg).

Make SFZ can create individual SFZ files for each audio file or, 
alternatively, it can create a single SFZ file in which every audio 
file is mapped to its own key.

Audio files can be treated as indiviual instruments or as instrument 
layers grouped either by sub-directory or by file name with numeric 
prefixes/suffixes indicating the layers.

EOF
'
commandToExec+='setTextColour $YELLOW; echo -e "Please enter the following details or simply press enter to accept the\ndefault values...\n"; setTextColour $WHITE; '

# Create a single file?
commandToExec+='echo "Do you want to create a single SFZ file? (default is no):"; setTextColour $CYAN; read -e isSingleFile; '
commandToExec+='if [[ $isSingleFile == "" ]]; then isSingleFile="no"; moveCursorUpOneLine; echo "$isSingleFile"; fi; setTextColour $WHITE; '

# if isSingleFile == yes
commandToExec+='if [[ $isSingleFile == [yY] ]] || [[ $isSingleFile == [yY][eE][sS] ]]; then '

commandToExec+='echo "Name of sfz file (default is name of current directory, \"${PWD##*/}\"):"; setTextColour $CYAN; read -e sfzFileName; '
commandToExec+='if [[ $sfzFileName == "" ]]; then sfzFileName="${PWD##*/}"; moveCursorUpOneLine; echo "$sfzFileName"; fi; setTextColour $WHITE; '

commandToExec+='echo "Start key (0 to 127, or C-1 to G9, # or b allowed) (default is C4):"; setTextColour $CYAN; read -e key; '
commandToExec+='if [[ $key == "" ]]; then key="C4"; moveCursorUpOneLine; echo "$key"; fi; setTextColour $WHITE; '

# else if isSingleFile == no
commandToExec+='elif [[ $isSingleFile == [nN] ]] || [[ $isSingleFile == [nN][oO] ]]; then '

commandToExec+='echo "Lowest key (0 to 127, or C-1 to G9, # or b allowed) (default is C-1):"; setTextColour $CYAN; read -e lokey; '
commandToExec+='if [[ $lokey == "" ]]; then lokey="C-1"; moveCursorUpOneLine; echo "$lokey"; fi; setTextColour $WHITE; '

commandToExec+='echo "Highest key (0 to 127, or C-1 to G9, # or b allowed) (default is G9):"; setTextColour $CYAN; read -e hikey; '
commandToExec+='if [[ $hikey == "" ]]; then hikey="G9"; moveCursorUpOneLine; echo "$hikey"; fi; setTextColour $WHITE; '

commandToExec+='echo "Pitch key center (0 to 127, or C-1 to G9, # or b allowed) (default is C4):"; setTextColour $CYAN; read -e keycenter; '
commandToExec+='if [[ $keycenter == "" ]]; then keycenter="C4"; moveCursorUpOneLine; echo "$keycenter"; fi; setTextColour $WHITE; '

# else isSingleFile is random gibberish
commandToExec+='else setTextColour $RED; echo -e "\nInvalid value: $isSingleFile"; exit 1; fi; '

# Set audio file format
if [ "$fileType" != "" ]; then
    commandToExec+="format='$fileType'; "
else
    commandToExec+='echo "Audio file format (wav (default), flac, or ogg):"; setTextColour $CYAN; read -e format; '
    commandToExec+='if [[ $format == "" ]]; then format="wav"; moveCursorUpOneLine; echo "$format"; fi; setTextColour $WHITE; '
fi

# Enable one-shot?
commandToExec+='echo "Enable one-shot? (default is no):"; setTextColour $CYAN; read -e isOneShotWanted; '
commandToExec+='if [[ $isOneShotWanted == "" ]]; then isOneShotWanted="no"; moveCursorUpOneLine; echo "$isOneShotWanted"; fi; setTextColour $WHITE; '

commandToExec+='if [[ $isOneShotWanted == [nN] ]] || [[ $isOneShotWanted == [nN][oO] ]]; then '
commandToExec+='isOneShotWanted=""; '

commandToExec+='elif [[ $isOneShotWanted != [yY] ]] && [[ $isOneShotWanted != [yY][eE][sS] ]]; then '
commandToExec+='setTextColour $RED; echo -e "\nInvalid value: $isOneShotWanted"; exit 1; fi; '

# Set MIDI channel
commandToExec+='echo "Set MIDI channel (1 - 16, or all) (default is \"all\"):"; setTextColour $CYAN; read -e midiChan; '
commandToExec+='if [[ $midiChan == "" ]]; then midiChan="all"; moveCursorUpOneLine; echo "$midiChan"; fi; setTextColour $WHITE; '

# Set "layer marker"
commandToExec+='echo "Set \"layer marker\" (none (default), dirs, prefix, or suffix (or d, p, or s)):"; setTextColour $CYAN; read -e layerMarker; '
commandToExec+='if [[ $layerMarker == "" ]]; then moveCursorUpOneLine; echo "none"; fi; '
commandToExec+='if [[ $layerMarker == "none" ]]; then layerMarker=""; fi; setTextColour $WHITE; '

# Reverse sort order
commandToExec+='echo "Reverse sort order? (default is no):"; setTextColour $CYAN; read -e isReverseSortOn; '
commandToExec+='if [[ $isReverseSortOn == "" ]]; then isReverseSortOn="no"; moveCursorUpOneLine; echo "$isReverseSortOn"; fi; setTextColour $WHITE; '

commandToExec+='if [[ $isReverseSortOn == [nN] ]] || [[ $isReverseSortOn == [nN][oO] ]]; then '
commandToExec+='isReverseSortOn=""; '

commandToExec+='elif [[ $isReverseSortOn != [yY] ]] && [[ $isReverseSortOn != [yY][eE][sS] ]]; then '
commandToExec+='setTextColour $RED; echo -e "\nInvalid value: $isReverseSortOn"; exit 1; fi; '

# Run makesfz
commandToExec+='echo; setTextColour $RED; '

commandToExec+="$MAKESFZ_FILEPATH "
commandToExec+='${sfzFileName:+-n "$sfzFileName" -s -k "$key"} ${lokey:+--lk "$lokey" --hk "$hikey" --kc "$keycenter"} -f "$format" ${isOneShotWanted:+-1} -m "$midiChan" ${layerMarker:+-L "$layerMarker"} ${isReverseSortOn:+-r} '
commandToExec+="${filePaths:+-- $filePaths}; "

commandToExec+='if [ $? -eq 0 ]; then setTextColour $YELLOW; echo -e "All done!"; fi'

$TERMINAL_COMMAND "$commandToExec"

